
# app.bigsexypoems.com

by [Ben Nadel][ben-nadel]


## Overview

[**BigSexyPoems**][app] is a poem editor built with **ColdFusion**, **HTMX**, and **Alpine.js**. It evolved from a static, Angular-based proof-of-concept hosted on Netlify into a full-stack application with persisted data, user accounts, and shareable poems.

Mostly, I just want a real-world application in which I can experiment with ideas and try out new paradigms for organizing my code.

Try it out: [app.bigsexypoems.com][app]


## Getting Started

### Prerequisites

* [Docker][docker] and Docker Compose
* A local hosts entry:

  ```hosts
  127.0.0.1	app.local.bigsexypoems.com
  ```

### Running the Application

```bash
docker compose up
```

The first startup can take 2-3 minutes while the [CommandBox image][commandbox-image] downloads ColdFusion. Subsequent startups are faster.

Once running, visit `https://app.local.bigsexypoems.com`. You'll need to accept the untrusted SSL certificate on your first visit.

To re-initialize the application, visit: `http://app.local.bigsexypoems.com/index.cfm?init=1`


## File and Folder Organization

The bulk of the application is stored in `cfml/app`, which is subdivided into the following folders:

* **`build`**: Client-side (JavaScript + LessCSS) compilation mechanics. This folder is mounted by the `client` and `client-dev` Docker containers.

  Each "entry point" in the Parcel.js build process corresponds to a "subsystem" `.js` file within the `client` folder. Each subsystem (e.g., `member`, `auth`) has a `.js` file that **glob-imports** all of the `**/*.js` and `**/*.less` files contained within that subsystem.

* **`client`**: The controller and view layer of the application. Contains all routing and view-related rendering logic.

  Unlike traditional MVC applications, the `client` folder **collocates** both Controller and View files side-by-side in the file-system. The biggest frustration I've historically felt with MVC is the distance between the `C` and `V` files, despite those layers being tightly coupled. Collocation eliminates that problem.

* **`config`**: Environment variables and settings. `config.template.json` documents the required structure; `config.json` (git-ignored) contains the concrete, secret-bearing settings.

* **`core`**: All business logic for the application.

  * **`lib`**: Model and service components.

    * **`classLoader`**: Components for loading vendor JAR files.

    * **`integration`**: External service integrations (Cloudflare Turnstile, Postmark, Bugsnag).

    * **`model`**: `*Model`, `*Gateway`, and `*Validation` components for entities. These are the low-level CRUD (Create, Read, Update, Delete) data abstractions. Also includes Markdown parsing and sanitization logic since it's tightly coupled to what it means to be an entity.

    * **`service`**: Orchestration components that model high-level business processes.

    * **`util`**: Non-application-specific components (e.g., the IoC `Injector`).

    * **`web`**: Browser-facing features like routing, request metadata, and error message translation.

  * **`vendor`**: 3rd-party JAR files and other dependencies.

  * **`cfmlx.cfm` (File)**: **Global e(X)tensions for CFML** &mdash; a `.cfm` file included in _every execution context_. Contains user-defined functions accessible without IoC ceremony: polyfills (`dump()`, `echo()`), shorthands (`e()`, `utcNow()`), and data-manipulation functions (`arrayCopy()`, `arrayPluck()`). I am very discerning about what goes in here.

* **`db`**: Database migration `.sql` files. Mounted by the `mysql` container as `/docker-entrypoint-initdb.d`, which executes them in lexicographic order on first database creation. After that, scripts are run manually as needed.

* **`email`**: Email templates.

* **`log`**: `CFDump`s of development errors. In the local environment, all `logger` calls are also output to `.txt` files so I don't miss behind-the-scenes bugs.

* **`upload`**: Not used, placeholder.

* **`wwwroot`**: Publicly accessible CFML files. The `index.cfm` file simply includes `/client/index.cfm`.

  * **`internal`**: Utility files for development (e.g., generating `HmacSha256` keys).

  * **`public/main`**: Files generated by the build system, consumed by ColdFusion layout templates via `cfinclude`.


## Client-Side Development

The client-side stack:

* [Alpine.js][alpinejs] &mdash; light-weight JavaScript framework
* [htmx][htmx] &mdash; AJAX-based extensions for HTML
* [LessCSS][lesscss] &mdash; CSS pre-processor
* [Parcel][parcel] &mdash; build tool for client assets

### Build Commands

All `npm` commands must be run inside the Docker `client` container &mdash; never directly on the host machine.

```bash
# One-time build
docker compose up client

# Watch mode with live rebuild
docker compose --profile dev up
```

### Installing Node Modules

Since Docker manages the `node_modules` folder, installing new dependencies requires shelling into the container:

1. Make sure neither `client` nor `client-dev` containers are running.
2. Run `docker compose run --rm client sh`.
3. Execute `npm` commands to modify the `package*.json` files.
4. Run `exit` to quit and remove the temporary container.

The `package.json` and `package-lock.json` files are mounted via Docker volumes, so changes made inside the container propagate back to the host.


## Local Services

### SMTP (MailHog)

Email is captured locally by [MailHog][mailhog-image].

Web interface: http://app.local.bigsexypoems.com:8025/

### MySQL

The database runs via the [MySQL Docker image][mysql-image]. Migration `.sql` files in `cfml/app/db/` are executed automatically on first container creation.


## Cloudflare Origin Server Certificates

> **Note**: This section is a personal ops runbook. I will almost certainly forget how all of this works by the next time I need it.

In production, this site is **proxied behind Cloudflare**. That means there are two TLS hops:

1. Browser &rarr; Cloudflare CDN (automatic, short-lived certificate)
2. Cloudflare CDN &rarr; Origin server (requires manual setup)

By default, the second hop is unencrypted. To enable end-to-end encryption, I use Cloudflare's **15-year origin server certificate**.

### Generating the Certificate

1. In the Cloudflare domain panel, go to **SSL/TLS** > **Origin Server**.
2. Click **Create Certificate**.
3. Use **RSA (2048)**.
4. Verify the hostnames include `bigsexypoems.com` and `*.bigsexypoems.com`.
5. Choose **15 years** expiration and click **Create**.
6. Save the certificate as `bigsexypoems.pem` and the private key as `bigsexypoems.key` (use **PEM** format).

### Converting for Windows IIS

Since the origin server runs Windows IIS, the PEM certificate needs to be converted to `.pfx`:

```sh
openssl pkcs12 -export \
  -out bigsexypoems.pfx \
  -inkey bigsexypoems.key \
  -in bigsexypoems.pem \
  -password pass:password
```

### Installing in IIS

1. Upload `bigsexypoems.pfx` to the Windows server.
2. In IIS, go to the root site and open **Server Certificates**.
3. Right-click > **Import**, select the `.pfx` file, and enter the password.
4. _(Optional)_ Use `mmc` with the Certificates snap-in to give the certificate a friendly name under **Local Computer / Personal / Certificates**.
5. In IIS, go to the ColdFusion site (e.g., `app.bigsexypoems.com`) and open **Edit Site Bindings**.
6. Add a binding:
   * Type: `https`
   * Host name: `app.bigsexypoems.com`
   * Enable: **Require server name indication**
   * SSL Certificate: the imported certificate

And that's all there is to it &mdash; just _6 easy steps_ after _6 other easy steps_ (lolol). But at least it lasts 15 years.


[alpinejs]: https://alpinejs.dev/
[app]: https://app.bigsexypoems.com/
[ben-nadel]: https://www.bennadel.com/
[commandbox-image]: https://hub.docker.com/r/ortussolutions/commandbox/
[docker]: https://www.docker.com/get-started/
[htmx]: https://htmx.org/
[lesscss]: https://lesscss.org/
[mailhog-image]: https://hub.docker.com/r/mailhog/mailhog/
[mysql-image]: https://hub.docker.com/_/mysql
[parcel]: https://parceljs.org/
