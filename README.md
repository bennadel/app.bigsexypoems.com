
# app.bigsexypoems.com

by [Ben Nadel][ben-nadel]


## Overview

This is a codification of my [**BigSexyPoems**][app] concept. Historically, the poem editor was a static, Angular-based proof-of-concept (PoC) application hosted on Netlify. I'm trying to transition that to a **ColdFusion**, **HTMX**, and **AlpineJS** application in which the poems can be saved and shared using persisted data.

Mostly, I just want a real-world application in which I can experiment with ideas and try out new paradigms for organizing my code.

Try it out for yourself: [https://app.bigsexypoems.com/][app]


## File And Folder Organization

The bulk of the application is stored in `cfml/app`. This folder is then subdivided into the following folders:

* **`build`**: Contains client-side (JavaScript + LessCSS) compilation mechanics. This folder is mounted by the `client` and `client-dev` Docker containers.

  Each "entry point" in the Parcel.js build process corresponds to a "subsystem" `.js` file within the `client` folder. Essentially, each subsystem (ex, `member`, `auth`), has a `.js` file which **glob-imports** all of the `**/*.js` and `**/*.less` files contained within that subsystem.

* **`client`**: The controller layer of the application. Contains all of the routing and view-related rendering logic.

  **Note**: Unlike your traditional MVC (Model-View-Controller) applications, the `client` folder contains _both_ the Controller and the View files. The biggest point-of-frustration that I've historically felt with MVC is the distance between the `C` and `V` files, despite the fact that these two layers are tightly coupled. My `client` folder **collocates** these two concerns, literally putting the "Controller" and "View" files side-by-side in the file-system.

* **`config`**: Contains the environment variables and settings. The `config.template.json` documents the structure of the configuration object. The `config.json` (which is ignored by `git`) defines the concrete settings.

* **`core`**: Contains all of the business logic for the application.

  * **`lib`**: Contains model and service components.

    * **`classLoader`**: Contains components for loading vendor JAR files.

    * **`integration`**: Contains components related to external service integration (ex, Cloudflare Turnstile, Postmark, Bugsnag).

    * **`model`**: Contains `*Model`, `*Gateway`, and `*Validation` components for entities. These are the low-level, CRUD (Create, Read, Update, Delete) data abstractions.

      I'm also including Markdown parser and sanitization logic along side the CRUD components since it feels like it's tightly coupled to the "what it means to be" an entity. But, they could have just as easily been in the `service` folder as well.

    * **`service`**: Contains "orchestration" components that model the high-level business processes of the application.

    * **`util`**: Contains non-application-specific components that don't neatly fit into the other folders.

    * **`web`**: Contains components for browser-facing features that help with things like routing, request metadata, and error message translation.

  * **`vendor`**: Contains 3rd-party JAR files and other dependencies.

  * **`cfmlx.cfm` (File)**: Contains **global e(X)tensions for CFML**. This is a `.cfm` file that I `include` into _every execution context_. It contains user defined functions that I want to be able to access without the ceremony of Inversion of Control (IoC) and componentization. It contains mostly polyfills (ex, `dump()` and `echo()`), short-hands (ex, `e()` and `utcNow()`), and data-manipulation functions (ex, `arrayCopy()` and `arrayPluck()`). I am very discerning about what I put in here.

* **`db`**: Contains the database migration `.sql` files.

  This folder is mounted by the `mysql` container as the `/docker-entrypoint-initdb.d` file, which executes the files in lexicographic order when the MySql database is created for the first time. Beyond that, I run these scripts manually as needed to keep the database up-to-date.

* **`email`**: Contains the email templates.

* **`log`**: Contains `CFDump`s of development errors. In the local environment, all `logger` calls are also output to `.txt` files to make sure I don't miss any behind-the-scenes bugs.

* **`upload`**: Not used, placeholder.

* **`wwwroot`**: Contains the publicly accessible CFML files. The `index.cfm` file does nothing but include `/client/index.cfm`.

  **`internal`**: Contains some utility files for development purposes (generating `HmacSha256` keys, for example).

  **`public/main`**: Contains files generated by the `build` system. These files are consumed by the ColdFusion layout templates via `cfinclude`.

## Docker Setup

The application runs locally using Docker. To run BigSexyPoems, simply run `docker compose up` from this directory. The application expects you to have an entry in your `etc/hosts` file for the local domain:

```hosts
127.0.0.1	app.local.bigsexypoems.com
```

Under the hood, I'm using the base [CommandBox image][commandbox-image], which will download the desired version of ColdFusion at start-up. As such, the start-up time can take 2-3 minutes for the `cfml` container.

> **Aside**: there's a way to optimize / finalize this, but I'm still very much a beginner when it comes to CommandBox.

The CommandBox image provides an "untrusted" SSL certificate in order to enable `https` locally. The first time you access `https://app.local.bigsexypoems.com`, you will need to _accept_ the SSL certificate - in the browser UI - in order to proceed to the site.


## Local SMTP Server

I'm using the [MailHog image][mailhog-image].

Web interface: http://app.local.bigsexypoems.com:8025/


## Local MySQL Database

I'm using the [MySql image][mysql-image].


## Client-Side Development

I'm using the following vendors for my client-side interactivity and styling:

* [Alpine.js][alpinejs] - light-weight JavaScript framework.
* [htmx][htmx] - AJAX-based extensions for HTML.
* [LessCSS][lesscss] - CSS pre-processor.
* [Parcel][parcel] - build tool for client assets.


## Installing `node` Modules

This is, by far, the jankiest part of this whole experiment. Since I'm using Docker to manage the `node_modules` folder, I can't "just" `npm install` new dependencies. Instead, I have to "bash into" a running `client` container and then invoke the `npm install --save-dev` from within the container context.

To do this:

* Make sure neither `client` nor `client-dev` container are running.
* Execute `docker compose run --rm client sh`.
* Execute `npm` commands to modify the `package*.json` files.
* Execute `exit` to quit and remove the temporary container.

Since the `package.json` and `package-lock.json` files are mounted via Docker volumes, the `npm install` commands, executed from within the running container, should propagate changes back to the host files.


[alpinejs]: https://alpinejs.dev/

[app]: https://app.bigsexypoems.com/

[ben-nadel]: https://www.bennadel.com/

[commandbox-image]: https://hub.docker.com/r/ortussolutions/commandbox/

[htmx]: https://htmx.org/

[lesscss]: https://lesscss.org/

[mailhog-image]: https://hub.docker.com/r/mailhog/mailhog/

[mysql-image]: https://hub.docker.com/_/mysql

[parcel]: https://parceljs.org/
